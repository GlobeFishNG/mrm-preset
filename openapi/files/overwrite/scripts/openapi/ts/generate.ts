import { generateFileList } from './utils';
import { OpenAPIV3 } from 'openapi-types';
import { validateYaml, isSwagger, NgApiInfo, ngApiInfoJoiSchema, bundleYaml } from './openapi';
import * as _ from 'lodash';
import { JSONSchema4 } from 'json-schema';
import * as js2joi from 'json-schema-to-joi';
import * as ejs from 'ejs';
import { fs } from 'mz';
import * as path from 'path';
import * as shelljs from 'shelljs';
import * as SwaggerParser from 'swagger-parser';
// tslint:disable: no-console

interface RenderOperation {
  name: string;
  method: string;
  operationCode: string;
  validator: {
    query?: string;
    params?: string;
    headers?: string;
    body?: string;
  };
}

interface RenderPath {
  uri: string;
  operations: RenderOperation[];
}

interface AppendFileContent {
  filter: string;
  fullContent: string;
}

interface AppendFileInfo {
  path: string;
  header: string;
  contents: AppendFileContent[];
}

const apiDocDir = './docs/api';
const apiOperations = ['get', 'put', 'post', 'delete', 'options', 'head', 'patch', 'trace'];
const tsAccessDir = './src/access';
const tsDir = './src';
const templatesDir = './scripts/openapi/templates';

const routerProcessorHeader =
`/**
 * All functions were automatically generated by \`yarn openapi:codegen\`.
 * DO NOT MODIFY THE NAME, PARAMETERS AND RETURN TYPE OF EVERY FUNCTION.
 * The implement code can be updated MANUALLY.
 */

/* eslint-disable prefer-arrow/prefer-arrow-functions */

import * as express from 'express';

export const defaultRequestHandler = (req: express.Request, res: express.Response, _next: express.NextFunction) => {
  res.setHeader('content-type', 'application/json');
  res.status(req.method === 'POST' ? 201: 200).end();
};
`;

const internalAppProcessorHeader =
`/* eslint-disable */

import * as express from 'express';
import { HttpError } from '@ngiq/nodejs-common';
`;

const externalAppProcessorHeader =
`/* eslint-disable */

import * as https from 'https';
import * as express from 'express';
import { HttpError } from '@ngiq/nodejs-common';

export interface HttpServerOptions {
  port: number;
}

export interface HttpsServerOptions extends HttpServerOptions {
  httpsOptions: https.ServerOptions;
}
`;

const getHttpServerOptions = 'function getHttpServerOptions';
const getHttpServerOptionsContent =
`export function getHttpServerOptions(): HttpServerOptions {
  // TODO: extend https.ServerOptions by adding customized parameters
}`;

const getHttpsServerOptions = 'function getHttpsServerOptions';
const getHttpsServerOptionsContent =
`export function getHttpsServerOptions(): HttpsServerOptions {
  // TODO: extend https.ServerOptions by adding customized parameters
}`;

const useCustomizedHandlerBeforeRouter = 'function useCustomizedHandlerBeforeRouter';
const useCustomizedHandlerBeforeRouterContent =
`export function useCustomizedHandlerBeforeRouter(_app: express.Application): void {
  // TODO: add customized handler before main router here
}`;

const useCustomizedHandlerAfterRouter = 'function useCustomizedHandlerAfterRouter';
const useCustomizedHandlerAfterRouterContent =
`export function useCustomizedHandlerAfterRouter(_app: express.Application): void {
  // TODO: add customized handler after main router here
}`;

const errorHandler = 'function errorHandler';
const errorHandlerContent =
`export function errorHandler(
  err: any, _req: express.Request, res: express.Response, next: express.NextFunction): void {
  // TODO: add customized errorHandler here
  if (err instanceof HttpError) {
    const errorDetails = err.valueObject;
    res.status(err.valueObject.statusCode).json({
      errorCode: \`\${errorDetails.serviceCode}-\${errorDetails.operationId}--\${err.code}\`,
      errorMsg: errorDetails.errorMsg,
    });
  } else {
    res.status(500).json({
      errorCode: 'N/A',
      errorMsg: 'N/A',
    });
  }
}`;

const healthCheck = 'function healthCheck';
const healthCheckContent =
`export function healthCheck(
  _req: express.Request, res: express.Response, _next: express.NextFunction): void {
  // TODO: add customized healthCheck here
  res.status(200).end();
}`;

const apps: string[] = [];

// tslint:disable-next-line: max-union-size
function getTemplateFile(type: 'router.ts' | 'function' | 'external.ts' | 'internal.ts' | 'main.ts'): string {
  return `${templatesDir}/${type}.ejs`;
}

async function main(): Promise<void> {
  const yamlFiles = generateFileList(apiDocDir, '.yml');

  for (const yamlFile of yamlFiles) {
    await generateApiCode(yamlFile);
  }

  generateMainFile();
  // generateHttpErrorFile();
}

function generateMainFile() {
  const result = ejs.render(fs.readFileSync(getTemplateFile('main.ts'), { encoding: 'utf8' }), 
  { 
    apps,
    appModules: apps.map(app => _.camelCase(app))
  });
  const mainFilePath = path.join('./src/main.ts');
  fs.writeFileSync(mainFilePath, result);
}

// function generateHttpErrorFile() {
//   const result = ejs.render(fs.readFileSync(getTemplateFile('http-error.ts'), { encoding: 'utf8' }));
//   const httpErrorFilePath = path.join('./src/http-error.ts');
//   fs.writeFileSync(httpErrorFilePath, result);
// }

function parsePath(
  apiPath: OpenAPIV3.PathItemObject, key: string,
  components: OpenAPIV3.ComponentsObject, $refs: SwaggerParser.$Refs): RenderPath {
  const renderPath: RenderPath = {
    uri: key.replace(/}/g, '').replace(/{/g, ':'),
    operations: [],
  };

  apiOperations.forEach((operation) => {
    const operationObj: OpenAPIV3.OperationObject = <OpenAPIV3.OperationObject>_.get(apiPath, operation);
    if (!operationObj) {
      return;
    }

    if (!operationObj.operationId) {
      console.warn('--> uri=', key, ', operation=', operation, 'misses operationId');
      throw new Error(`uri: ${key}, operation: ${operation} don't have a operationId`);
    }

    if ((operationObj as any)['x-operation-code'] === undefined) {
      console.warn('--> uri=', key, ', operation=', operation, 'misses x-operation-code');
      throw new Error(`uri: ${key}, operation: ${operation} don't have a x-operation-code`);
    }

    const operationId = _.camelCase(operationObj.operationId);
    const renderOperation: RenderOperation = {
      name: _.upperFirst(operationId),
      method: operation,
      operationCode: (operationObj as any)['x-operation-code'],
      validator: {},
    };

    if (operationObj.parameters) {
      parsePathParameters(
        operationId, operationObj.parameters, renderOperation,
        components, $refs
      );
    }

    if (operationObj.requestBody) {
      parsePathRequestBody(operationId, operationObj.requestBody, renderOperation,
      components, $refs);
    }
    renderPath.operations.push(renderOperation);

  });

  return renderPath;
}

function parsePathRequestBody(
  operationId: string, requestBody: OpenAPIV3.ReferenceObject | OpenAPIV3.RequestBodyObject, renderOperation: RenderOperation,
  components: OpenAPIV3.ComponentsObject, $refs: SwaggerParser.$Refs): void {

  let requestBodyObject: OpenAPIV3.RequestBodyObject;
  if ((<OpenAPIV3.ReferenceObject>requestBody).$ref) {
    const referenceObject = <OpenAPIV3.ReferenceObject>requestBody;
    requestBodyObject = <OpenAPIV3.RequestBodyObject>$refs.get(referenceObject.$ref);
  } else {
    requestBodyObject = <OpenAPIV3.RequestBodyObject>requestBody;
  }

  _.forEach(requestBodyObject.content, (mediaTypeObj, bodyKey) => {
    if (bodyKey.toLocaleLowerCase() !== 'application/json') {
      console.warn('--> Unsupported Media Type:', bodyKey);
      return;
    }

    if (!mediaTypeObj.schema) {
      return;
    }

    const schema = mediaTypeObj.schema;

    let deRefer = schema;
    while (true) {
      const $ref = (<OpenAPIV3.ReferenceObject>deRefer).$ref;
      if (!$ref) {
        break;
      } else {
        deRefer = <OpenAPIV3.SchemaObject | OpenAPIV3.ReferenceObject>$refs.get($ref);
      }
    }

    components.schemas![operationId + 'BundledBodyParameters'] = deRefer;
    renderOperation.validator.body = _.camelCase(operationId + 'BundledBodyParameters' + 'JoiSchema');
  });
}

function parsePathParameters(
  operationId: string, parameters: (OpenAPIV3.ParameterObject | OpenAPIV3.ReferenceObject)[], renderOperation: RenderOperation,
  components: OpenAPIV3.ComponentsObject, $refs: SwaggerParser.$Refs): void {

  let pathSchema: OpenAPIV3.SchemaObject | undefined;
  let headerSchema: OpenAPIV3.SchemaObject | undefined;
  let querySchema: OpenAPIV3.SchemaObject | undefined;

  parameters.forEach((parameter) => {
    let parameterObject: OpenAPIV3.ParameterObject;
    if ((<OpenAPIV3.ReferenceObject>parameter).$ref) {
      const referenceObject = <OpenAPIV3.ReferenceObject>parameter;
      parameterObject = <OpenAPIV3.ParameterObject>$refs.get(referenceObject.$ref);
    } else {
      parameterObject = <OpenAPIV3.ParameterObject>parameter;
    }

    const schema = parameterObject.schema;

    let type: string;

    let deRefer = schema;
    while (true) {
      const $ref = (<OpenAPIV3.ReferenceObject>deRefer).$ref;
      if (!$ref) {
        type = (<OpenAPIV3.SchemaObject>deRefer).type;
        break;
      } else {
        deRefer = <OpenAPIV3.SchemaObject | OpenAPIV3.ReferenceObject>$refs.get($ref);
      }
    }
    const isPrimitive = (type === 'null' || type === 'boolean' || type === 'number' ||
      type === 'string' || type === 'integer');

    const name = parameterObject.name;
    const required = parameterObject.required;

    const update = (targetSchema: OpenAPIV3.SchemaObject | undefined): OpenAPIV3.SchemaObject => {
      let updatedSchema: OpenAPIV3.SchemaObject
        = targetSchema ? _.cloneDeep(targetSchema) : { type: 'object', properties: {}, required: [] };

      if (isPrimitive) {
        updatedSchema.properties![name] = schema!;
        if (required) {
          updatedSchema.required!.push(name);
        }
      } else {
        updatedSchema = <OpenAPIV3.SchemaObject>deRefer;
      }
      return updatedSchema;
    };

    switch (parameterObject.in) {
      case 'path':
        pathSchema = update(pathSchema);
        break;
      case 'header':
        headerSchema = update(headerSchema);
        break;
      case 'query':
        querySchema = update(querySchema);
        break;
      default:
        console.warn(`param type ${parameterObject.in} not supported!`);
        break;
    }
  });

  if (headerSchema) {
    components.schemas![operationId + 'BundledHeaderParameters'] = headerSchema;
    renderOperation.validator.headers = _.camelCase(operationId + 'BundledHeaderParameters' + 'JoiSchema');
  }
  if (querySchema) {
    components.schemas![operationId + 'BundledQueryParameters'] = querySchema;
    renderOperation.validator.query = _.camelCase(operationId + 'BundledQueryParameters' + 'JoiSchema');
  }
  if (pathSchema) {
    components.schemas![operationId + 'BundledPathParameters'] = pathSchema;
    renderOperation.validator.params = _.camelCase(operationId + 'BundledPathParameters' + 'JoiSchema');
  }
}

function parsePaths(api: OpenAPIV3.Document, components: OpenAPIV3.ComponentsObject, $refs: SwaggerParser.$Refs): RenderPath[] {
  return _.map(api.paths, (apiPath, key) => {
    return parsePath(apiPath, key, components, $refs);
  });
}

async function appendFunctionsToTsFile(info: AppendFileInfo): Promise<void> {
  let fileContent = '';
  if (!await fs.stat(info.path).then((value) => value.isFile()).catch((_error) => false)) {
    fs.writeFileSync(info.path, info.header);
  } else {
    fileContent = fs.readFileSync(info.path, { encoding: 'utf8' });
  }

  info.contents.forEach((value) => {
    if (fileContent.indexOf(`${value.filter}`) >= 0) {
      return;
    }
    fs.appendFileSync(info.path, '\n' + value.fullContent + '\n');
  });
}

async function generateApiCode(yamlFile: string): Promise<void> {
  console.log('Generate API code from', yamlFile);
  await validateYaml(yamlFile);
  const api: OpenAPIV3.Document = <OpenAPIV3.Document>await bundleYaml(yamlFile);
  const $refs = await SwaggerParser.resolve(api);
  const bundledComponents: OpenAPIV3.ComponentsObject = api.components ? api.components : {};
  if (isSwagger(api)) {
    console.warn('Don\'t support Swagger 2.x, please change to OpenAPI 3.0.x!');
    return;
  }

  const oasApi = api;

  let xNgApiInfo = <NgApiInfo>_.get(oasApi, 'x-neuralgalaxy-api-info');

  const joiRet = ngApiInfoJoiSchema.validate(xNgApiInfo, {
    allowUnknown: true,
    convert: true,
    stripUnknown: { objects: true, arrays: false, },
  });

  if (joiRet.error) {
    console.warn('--> API yaml doesn\'t include valid x-neuralgalaxy-api-info', joiRet.error.details[0].message);
    throw new Error('API yaml doesn\'t include valid x-neuralgalaxy-api-info');
  }

  xNgApiInfo = <NgApiInfo>joiRet.value;

  const apiPaths = parsePaths(oasApi, bundledComponents, $refs);

  const joiSchemas =  js2joi.resolveBundledJSONSchema(<{[k: string]: JSONSchema4}>bundledComponents.schemas, { rootSchema: { components: bundledComponents }});
  const joiStats: js2joi.JoiStatement[] = [];
  joiSchemas.forEach((subSchema) => {
    joiStats.push(...js2joi.generateJoiStatement(subSchema, true));
  });

  const bundledJoiStrings = js2joi.formatJoi(joiStats, {
    withExport: true,
    withTypeDeclaration: true,
    joiName: 'Joi',
    extendedJoiName: 'Joi.extendedJoi',
    prettierOptions: {
      semi: true,
      singleQuote: true,
    }
  });

  if (apiPaths.length === 0) {
    console.log('--> API yaml file doesn\'t include any path, so it will be ignored as a reference file.');
    return;
  }

  const fileInfo = path.parse(yamlFile);
  fileInfo.name = _.kebabCase(fileInfo.name);
  const ejsResult = ejs.render(fs.readFileSync(getTemplateFile('router.ts')).toString('utf8'),
  {
    paths: apiPaths,
    apiName: fileInfo.name,
    apiCode: xNgApiInfo.serviceCode,
    bundledJoiStrings,
  });

  shelljs.mkdir('-p', tsAccessDir);
  fs.writeFileSync(path.join(tsAccessDir, fileInfo.name + '.router.ts'), ejsResult);

  const routerAppendFileInfo: AppendFileInfo = {
    path: path.join(tsAccessDir, fileInfo.name + '.routerprocessor.ts'),
    header: routerProcessorHeader,
    contents: []
  };

  apiPaths.forEach((value: RenderPath) => {
    value.operations.forEach((operation) => {
      const fullContent
      = ejs.render(fs.readFileSync(getTemplateFile('function'), { encoding: 'utf8' }), { name: operation.name });
      routerAppendFileInfo.contents.push({
        filter: `function process${operation.name}`,
        fullContent,
      });
    });
  });

  await appendFunctionsToTsFile(routerAppendFileInfo);

  const app = {
    name: fileInfo.name,
    ...xNgApiInfo,
  };

  const appFileName = path.join(tsDir, fileInfo.name + '.app.ts');
  let appFileContent = '';
  const appendInfo: AppendFileInfo = {
    header: '',
    path: path.join('./src', fileInfo.name + '.appprocessor.ts'),
    contents: [{
      filter: useCustomizedHandlerBeforeRouter,
      fullContent: useCustomizedHandlerBeforeRouterContent,
    }, {
      filter: useCustomizedHandlerAfterRouter,
      fullContent: useCustomizedHandlerAfterRouterContent,
    }, {
      filter: errorHandler,
      fullContent: errorHandlerContent,
    }, {
      filter: healthCheck,
      fullContent: healthCheckContent,
    }],
  };
  if (xNgApiInfo.network === 'internal-data-network') {
    appFileContent = ejs.render(fs.readFileSync(getTemplateFile('internal.ts'), { encoding: 'utf8' }), { app });
    appendInfo.header = internalAppProcessorHeader;
  } else {
    appFileContent = ejs.render(fs.readFileSync(getTemplateFile('external.ts'), { encoding: 'utf8' }), { app });
    appendInfo.header = externalAppProcessorHeader;
    appendInfo.contents.push({
      filter: getHttpServerOptions,
      fullContent: getHttpServerOptionsContent,
    });
    appendInfo.contents.push({
      filter: getHttpsServerOptions,
      fullContent: getHttpsServerOptionsContent,
    });
  }
  fs.writeFileSync(appFileName, appFileContent);
  await appendFunctionsToTsFile(appendInfo);
  apps.push(app.name);
}

main()
  .then(() => {
    console.log('Generate API Code Successfully!');
    process.exit(0);
  })
  .catch((error) => {
    console.error('Generate API Code Failed:', error);
    process.exit(-1);
  });