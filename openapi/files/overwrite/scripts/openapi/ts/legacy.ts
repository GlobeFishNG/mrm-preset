import { OpenAPIV3, OpenAPIV2 } from 'openapi-types';
import { generateFileList } from './utils';
import { compile } from 'json-schema-to-typescript';
import { resolveBundledJSONSchema, generateJoiStatement, formatJoi, JoiStatement } from 'json-schema-to-joi';
import { JSONSchema4 } from 'json-schema';
import * as path from 'path';
import * as shelljs from 'shelljs';
import { fs } from 'mz';
import * as $RefParser from 'json-schema-ref-parser';
import { validateYaml, isSwagger, bundleYaml } from './openapi';

// tslint:disable: no-console

// tslint:disable-next-line: one-variable-per-declaration
const bannerComment =
  `
/* tslint:disable */
/**
 * This file was automatically generated by \`yarn compile:genapicode\`.
 * DO NOT MODIFY IT MANUALLY. Instead, modify the source OpenAPI/Swagger YAML file,
 * and run \`yarn compile:genapicode\` to regenerate this file.
 */
`;

const joiImport = `import { Joi } from '@ses/common';\n`

async function main(): Promise<void> {
  console.log('Processing OpenAPI/Swagger YAML files...');
  await processYaml();
  console.log('Processing OpenAPI/Swagger YAML related JSON Schema files...');
  await processJson();
}

async function generateTs(
  jsonSchema: { definitions: JSONSchema4 }, inFile: string, outFile: string): Promise<void> {
  const output = await compile(jsonSchema, '', {
    enableConstEnums: false,
    style: {
      singleQuote: true,
    },
    cwd: path.parse(inFile).dir,
    unreachableDefinitions: true,
    declareExternallyReferenced: true,
    bannerComment,
  });

  fs.writeFileSync(outFile, output, { encoding: 'utf8' });
}

async function generateJoi(
  jsonSchema: { definitions: JSONSchema4 }, _inFile: string, outFile: string): Promise<void> {
  const joiSchemas = resolveBundledJSONSchema(jsonSchema.definitions, {
    useDeprecatedJoi: true,
    useExtendedJoi: true,
    rootSchema: jsonSchema,
  });
  const joiStats: JoiStatement[] = [];
  joiSchemas.forEach((subSchema) => {
    joiStats.push(...generateJoiStatement(subSchema, true));
  });

  const output = formatJoi(joiStats, {
    withExport: true,
    withTypeDeclaration: true,
    joiName: 'Joi',
    extendedJoiName: 'Joi.extendedJoi',
    prettierOptions: {
      semi: true,
      singleQuote: true,
    }
  });
  fs.writeFileSync(outFile, bannerComment + '\n' + joiImport + '\n' + output, { encoding: 'utf8' });
}

async function processJson(): Promise<void> {
  const jsonFiles = generateFileList('./docs/api/', '.json');
  for (const jsonFile of jsonFiles) {
    console.log('--> Parsing JSON schema', jsonFile, '...');
    const content = await $RefParser.bundle(jsonFile);
    if (content && content.definitions) {
      console.log('--> Generating API code...');
      const relative = path.parse(path.relative('./docs/api', jsonFile));
      const outputDir = path.join('src/generated/', relative.dir);
      shelljs.mkdir('-p', outputDir);
      const outputTsFile = path.join(outputDir, relative.name + '.ts');
      await generateTs({ definitions: content.definitions }, jsonFile, outputTsFile);
      console.log('--> Output Typescript interface file:', outputTsFile);
    }
  }
}

interface IndexedObj {
  // tslint:disable-next-line: max-union-size
  [k: string]: IndexedObj | string | number | boolean;
  // tslint:disable-next-line: max-union-size
  [k: number]: IndexedObj | string | number | boolean;
}

function convertRefFromV3toV2(obj: IndexedObj): void {
  if (obj && typeof obj === 'object') {
    Object.keys(obj).forEach((key) => {
      if (key === '$ref' && typeof obj[key] === 'string') {
        const ref = <string>(obj[key]);
        obj[key] = ref.replace('#/components/schemas', '#/definitions');
      } else {
        const subObj = obj[key];
        if (typeof subObj !== 'string'
          && typeof subObj !== 'number'
          && typeof subObj !== 'boolean') {
          convertRefFromV3toV2(subObj);
        }
      }
    });
  }
}

async function processYaml(): Promise<void> {
  const yamlFiles = generateFileList('./docs/api/', '.yaml');
  for (const yamlFile of yamlFiles) {
    let bundledJsonSchemas: { definitions: JSONSchema4 } | undefined;
    await validateYaml(yamlFile);
    const bundledApi = await bundleYaml(yamlFile);
    if (isSwagger(bundledApi)) {
      const bundledSwagger = <OpenAPIV2.Document>bundledApi;
      bundledJsonSchemas = bundledSwagger.definitions ? { definitions: bundledSwagger.definitions } : undefined;
    } else {
      const bundledOas3 = <OpenAPIV3.Document>bundledApi;
      bundledJsonSchemas = bundledOas3.components && bundledOas3.components.schemas ?
        { definitions: bundledOas3.components.schemas } : undefined;
      if (bundledJsonSchemas) {
        convertRefFromV3toV2(bundledJsonSchemas);
      }
    }

    const relative = path.parse(path.relative('./docs/api', yamlFile));
    const outputDir = path.join('src/generated/', relative.dir, relative.name);

    console.log('--> Generating API code...');

    if (bundledJsonSchemas) {
      shelljs.mkdir('-p', outputDir);
      const outputTsFile = path.join(outputDir, 'api_definitions.ts');
      await generateTs(bundledJsonSchemas, yamlFile, outputTsFile);
      console.log('--> Output Typescript interface file:', outputTsFile);
      const outputJoiFile = path.join(outputDir, 'joi_schemas.ts');
      await generateJoi(bundledJsonSchemas, yamlFile, outputJoiFile);
      console.log('--> Output Joi schema file:', outputJoiFile);
    }
  }
}

main().then(() => {
  console.log('Generate API code successfully.');
  process.exit(0);
}).catch((err) => {
  console.error('Error occurs: ', err);
  process.exit(-1);
});